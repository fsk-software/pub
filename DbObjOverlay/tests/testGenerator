#!/usr/bin/python3
import argparse
import logging
import sys
sys.path.append('../')
import odbPreprocessor
import re
import CppGenerator
from CppGenerator import TypeRegistry

def camelCase(el):
    retVal=[el[0].upper()+el[1:]]
    return "".join(retVal)

def defaultValues(dType):
  m=re.match('.*\((.*)\).*',dType)
  pType=dType.replace('(%s)'%(m.group(1)),'()') if m else dType
  DefaultVals={
                "int"     : "1",
                "float"   : "1.2345",
                "double"  : "2.4680",
                "text"    : '"abc"',
                "char"    : "'x'",
                "char()"  : '"abc"',
                "bigint"  : "100",
                "long"    : "9999",
              };
  retVal=DefaultVals[pType];
  return retVal

class TestObj:
  def __init__(self,id,name,objList):
    self.id_=id
    self.name_=name
    self.tests_=[]
    self.objList_=objList
    self.testNames_=[]
    self.tests_+=self.simpleTest()

  def objCtor(self,objName):
    L=[]
    pKeys=[el for el in self.objList_ if el.isKey]
    L.append("//pKeys: %s"%(str(pKeys)))
    pKey=pKeys[0]
    i=0
    pKeyList=[]
    for pKey in pKeys:
      L.append("//pKey.type: %s"%(str(pKey.type)))
      dType=TypeRegistry.typeConverter(pKey.type) if TypeRegistry.isPrimitiveType(pKey.type) else "%s::%s"%(self.name_,TypeRegistry.typeConverter(pKey.type))
      keyVarName='pKey%d'%(i)
      pKeyList.append(keyVarName)
      if pKey.type in ['int','float','double','text','char','bigint','long']:
        L.append("%s %s;"%(dType,'%s=%s'%(keyVarName,defaultValues(pKey.type))))
      else:
        L.append("%s %s;"%(dType,'%s(%s)'%(keyVarName,defaultValues(pKey.type))))
      i+=1
    L.append("%s %s(%s);"%(self.name_,objName,','.join(pKeyList)))
    return L

  def objSetter(self, el,val):
    fxn="set"+el.name[0].upper()+el.name[1:]
    return ['obj.%s(%s);'%(fxn,val)]

  def objGetter(self, el):
    fxn="get"+el.name[0].upper()+el.name[1:]
    return ['obj.%s()'%(fxn)]

  def simpleTest(self):
    L=[]
    fxnName='test%05d'%(self.id_)
    fxnName='test%sSimpleTest'%(self.name_)
    self.testNames_.append("")
    L.append('void %s()'%(fxnName))
    L.append('{')
    L.append('  dropTable("%s");'%(self.name_))
    for e in self.objCtor('obj'):
      L.append('  %s'%(e))
    mutableFields=[el for el in self.objList_ if not el.isKey]
    L.append("  // mutable: %s"%(str(mutableFields)))
    for e in mutableFields:
      L.append('  {')
      newVar='newVal'
      if e.type in ['float','bigint','text','char','int','long','double','date','datetime']:
        varDeclaration=TypeRegistry.typeConverter(e.type) if TypeRegistry.isPrimitiveType(e.type) else "%s::%s"%(self.name_,TypeRegistry.typeConverter(e.type))
        print("varDeclaration:",varDeclaration)
        L.append('    const %s %s=%s;'%(varDeclaration, newVar, defaultValues(e.type)))
      else:
        L.append('    //e.type: %s'%(e.type))
        typeName="%s::%s"%(self.name_,CppGenerator.UserTypeGenerator.typeName(e.type))
        L.append('    const %s %s("");'%(typeName,newVar))
      for el in self.objSetter(e,newVar):
        L.append("    %s"%(el))
      for el in self.objGetter(e):
        L.append("    assert(%s==%s);"%(newVar,el))
      L.append("    {")
      L.append("      %s obj2(pKey0);"%(self.name_))
      obj1Getter=''.join(self.objGetter(e))
      obj2Getter=obj1Getter.replace('obj','obj2')
      L.append("      assert(%s==%s);"%(obj1Getter,obj2Getter))
      L.append("    }")
      L.append('  }')
    L.append('}')
    L.append('')
    return L

class TestModule:
  def __init__(self,name,objList):
    self.name_=name
    self.tests_=[]
    logging.debug("test object: %s %s"%(name, objList))
    i=0
    tc=TestObj(i,name,objList)
    self.tests_+=tc.tests_

def processFiles(fileList):
  retVal=[]
  obj=odbPreprocessor.Odb()
  for file in fileList:
    logging.debug('processing %s'%(file))
    dbEls=obj.parseOdbFile(file)
    logging.debug('dbEls %s'%(dbEls))
    for k,v in dbEls.items():
      logging.debug('processing %s; %s'%(k,v))
      tObj=TestModule(k,v)
      retVal+=tObj.tests_
  return retVal

def helperFunctions():
  retVal=[]
  L.append("void dropTable(const std::string& tableName)")
  L.append("{");
  L.append("  try");
  L.append("  {");
  L.append('    DbConnector::instance()->execute("DROP TABLE " + tableName + ";");')
  L.append("  }");
  L.append("  catch(sql::SQLException e)");
  L.append("  {");
  L.append("  }");
  L.append("}");
  return retVal

#--main--
if __name__ == "__main__":
  parser=argparse.ArgumentParser(description='ODB precompiler')
  parser.add_argument('--verbose',action='store_true', default=False)
  parser.add_argument('--input',action='append',required=True, default=[])
  parser.add_argument('--outfile',action='store',required=True)
  args,unk = parser.parse_known_args()

  if args.verbose:
    logLevel=logging.DEBUG
  else:
    logLevel=logging.INFO
  logging.basicConfig(format='%(asctime)s [%(filename)s:%(lineno)s] %(levelname)s: %(message)s', datefmt='%Y-%m-%d %I:%M:%S %p',level=logLevel)

  tL=processFiles(args.input)

  L=[]
  L.append('#include "log4cxx/logger.h"')
  L.append('#include "log4cxx/basicconfigurator.h"')
  L.append('#include <chrono>')
  for e in args.input:
    L.append('#include "%s.h"'%(e.replace('.odb','')))
  for e in helperFunctions():
    L.append("%s"%(e))
  L.append('')
  L+=tL
  L.append('int main(int argc, char* argv[])')
  L.append('{')
  L.append('  using namespace log4cxx;')
  L.append('  using namespace log4cxx::helpers;')
  L.append('  BasicConfigurator::configure();')
  L.append('  LoggerPtr logger(Logger::getLogger("main"));')
  L.append('  const auto startTs{std::chrono::steady_clock::now()};')
  testFxns=[el for el in tL if re.match('.*void test.*()',el)]
  print("testFxns:",testFxns)
  for e in testFxns:
    call=e.split(' ')[1]
    L.append('  %s;'%(call))
  L.append('  const auto stopTs{std::chrono::steady_clock::now()};')
  L.append('  const std::chrono::duration<double> elapsedSecs{stopTs - startTs};')
  L.append('  LOG4CXX_DEBUG(logger, "main process terminating; elapsed time(" << elapsedSecs.count() << ")");')


  L.append('  return(EXIT_SUCCESS);')
  L.append('}')
  L.append('')
  with open(args.outfile,'w') as fp:
    fp.write('\n'.join(L))
